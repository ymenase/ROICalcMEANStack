{
  "_from": "express-error-handler",
  "_id": "express-error-handler@1.1.0",
  "_inBundle": false,
  "_integrity": "sha1-/y7bH+3PyrHmAcYKqzVUmC8fZJc=",
  "_location": "/express-error-handler",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "express-error-handler",
    "fetchSpec": "latest",
    "name": "express-error-handler",
    "raw": "express-error-handler",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/express-error-handler/-/express-error-handler-1.1.0.tgz",
  "_shasum": "ff2edb1fedcfcab1e601c60aab3554982f1f6497",
  "_spec": "express-error-handler",
  "_where": "/Users/yvettemenase/apps/ROICalcMEANStack",
  "author": {
    "name": "Eric Elliott"
  },
  "bugs": {
    "url": "https://github.com/dilvie/express-error-handler/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "mout": "0.12.0"
  },
  "deprecated": false,
  "description": "A graceful error handler for Express applications.",
  "devDependencies": {
    "bunyan-request-logger": "1.0.2",
    "connect-cache-control": "1.0.0",
    "express": "^4.9.8",
    "grunt": "~0.4.1",
    "grunt-contrib-jshint": "1.0.0",
    "restify": "4.0.4",
    "supertest": "1.2.0",
    "tape": "4.5.1",
    "through": "~2.3.4",
    "updtr": "0.1.7",
    "watch": "0.17.1"
  },
  "homepage": "https://github.com/dilvie/express-error-handler#readme",
  "keywords": [
    "connect",
    "error",
    "errors",
    "express",
    "handler",
    "handling"
  ],
  "license": "MIT",
  "main": "error-handler.js",
  "name": "express-error-handler",
  "optionalDependencies": {},
  "readme": "express-error-handler\n=====================\n\nA graceful error handler for Express applications. This also patches a DOS exploit where users can manually trigger bad request errors that shut down your app.\n\n\n## Quick start:\n\n```js\nvar express = require('express'),\n  errorHandler = require('../error-handler.js'),\n  app = express(),\n  env = process.env,\n  port = env.myapp_port || 3000,\n  http = require('http'),\n  server;\n\n// Route that triggers a sample error:\napp.get('/error', function createError(req,\n    res, next) {\n  var err = new Error('Sample error');\n  err.status = 500;\n  next(err);\n});\n\n// Create the server object that we can pass\n// in to the error handler:\nserver = http.createServer(app);\n\n// Log the error\napp.use(function (err, req, res, next) {\n  console.log(err);\n  next(err);\n});\n\n// Respond to errors and conditionally shut\n// down the server. Pass in the server object\n// so the error handler can shut it down\n// gracefully:\napp.use( errorHandler({server: server}) );\n\nserver.listen(port, function () {\n  console.log('Listening on port ' + port);\n});\n```\n\n## Configuration errorHandler(options)\n\nHere are the parameters you can pass into the `errorHandler()` middleware:\n\n* @param {object} [options]\n\n* @param {object} [options.handlers] Custom handlers for specific status codes.\n* @param {object} [options.views] View files to render in response to specific status codes. Specify a default with `options.views.default`\n* @param {object} [options.static] Static files to send in response to specific status codes. Specify a default with options.static.default.\n* @param {number} [options.timeout] Delay between the graceful shutdown attempt and the forced shutdown timeout.\n* @param {number} [options.exitStatus] Custom process exit status code.\n* @param {object} [options.server] The app server object for graceful shutdowns.\n* @param {function} [options.shutdown] An alternative shutdown function if the graceful shutdown fails.\n* @param {function} serializer a function to customize the JSON error object. Usage: serializer(err) return errObj\n* @param {function} framework Either 'express' (default) or 'restify'.\n* @return {function} errorHandler Express error handling middleware.\n\n### Examples:\n\n`express-error-handler` lets you specify custom templates, static pages, or error handlers for your errors. It also does other useful error-handling things that every app should implement, like protect against 4xx error DOS attacks, and graceful shutdown on unrecoverable errors. Here's how you do what you're asking for:\n\n\n```js\nvar errorHandler = require('express-error-handler'),\n  handler = errorHandler({\n    handlers: {\n      '404': function err404() {\n        // do some custom thing here...\n      }\n    }\n  });\n\n// After all your routes...\n// Pass a 404 into next(err)\napp.use( errorHandler.httpError(404) );\n\n// Handle all unhandled errors:\napp.use( handler );\n```\n\nOr for a static page:\n\n```js\nhandler = errorHandler({\n  static: {\n    '404': function err404() {\n      // do some custom thing here...\n    }\n  }\n});\n```\n\nOr for a custom view:\n```js\nhandler = errorHandler({\n  views: {\n    '404': function err404() {\n      // do some custom thing here...\n    }\n  }\n});\n```\n\nOr for a custom JSON object:\n```js\nvar errorHandler = require('express-error-handler'),\n  handler = errorHandler({\n    serializer: function(err) {\n      var body = {\n        status: err.status,\n        message: err.message\n      };\n      if (createHandler.isClientError(err.status)) {\n        ['code', 'name', 'type', 'details'].forEach(function(prop) {\n          if (err[prop]) body[prop] = err[prop];\n        });\n      }\n      return body;\n    }\n  });\n```\n\n[More examples](https://github.com/dilvie/express-error-handler/tree/master/examples) are available in the examples folder.\n\n## errorHandler.isClientError(status)\n\nReturn true if the error status represents a client error that should not trigger a restart.\n\n* @param  {number} status\n* @return {boolean}\n\n\n### Example\n\n```js\nerrorHandler.isClientError(404); // returns true\nerrorHandler.isClientError(500); // returns false\n```\n\n\n## errorHandler.httpError(status, [message])\n\nTake an error status and return a route that sends an error with the appropriate status and message to an error handler via `next(err)`.\n\n* @param  {number} status\n* @param  {string} message\n* @return {function} Express route handler\n\n```js\n// Define supported routes\napp.get( '/foo', handleFoo() );\n// 405 for unsupported methods.\napp.all( '/foo', createHandler.httpError(405) );\n```\n\n## Restify support\n\nRestify error handling works different from Express. To trigger restify mode, you'll need to pass the `framework` parameter when you create the errorHandler:\n\n```js\nvar handleError = errorHandler({\n  server: server\n  framework: 'restify'\n});\n```\n\nIn restify, `next(err)` is synonymous with `res.send(status, error)`. This means that you should *only use `next(err)` to report errors to users*, and not as a way to aggregate errors to a common error handler. Instead, you can invoke an error handler directly to aggregate your error handling in one place.\n\nThere is no error handling middleware. Instead, use `server.on('uncaughtException', handleError)`\n\nSee the examples in `./examples/restify.js`\n\n\n## Credit and Thanks\n\nWritten by [Eric Elliott](http://ericelliottjs.com/) for the book, [\"Programming JavaScript Applications\"](http://pjabook.com) (O'Reilly)\n\n* [Nam Nguyen](https://github.com/gdbtek) for bringing the Express DOS exploit to my attention.\n* [Samuel Reed](https://github.com/strml) for helpful suggestions.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/dilvie/express-error-handler.git"
  },
  "scripts": {
    "latest": "updtr",
    "lint": "grunt hint",
    "pretest": "npm run -s lint",
    "start-example": "node examples/app.js | bunyan",
    "test": "node ./test/runtests.js",
    "watch": "watch 'clear && npm run -s test' ."
  },
  "version": "1.1.0"
}
